#! /bin/sh
#
# Giuseppe Ciaccio 15 November 2000
# This script is derived from the mpirun.args original script of MPICH .
#
hasprinthelp=1
progname=
cmdLineArgs=
machineFile=
machineFileArg=
fake_progname=
np=1
mpirun_verbose=0
just_testing=0
machineFileArg=
machineFile=
Show=eval
#
PrintHelp() {
#
# If you change this, make the corresponding changes in README so that
# the man pages are updated.
#
cat <<EOF
mpirun [mpirun_options...] <progname> [options...]

  mpirun_options:
    -h      This help
    -machinefile <machine-file name>
	    The file is a list of machines to be involved in the job run.
	    Local machine is always involved (and hosts instance #0).
            Default machine file is /etc/gamma.conf
    -np <np>
            specify the number of process instances to be generated.
    -t      Testing - do not actually run, just print what would be
            executed
    -v      Verbose - throw in some comments

Multiple architectures as well as multiple pathnames for the executables
cannot be handled yet.

EOF
}

while [ 1 -le $# ] ; do
  arg=$1
  #echo $arg
  #echo $#
  shift
  case $arg in 
     -arch) 
	shift
	;;
    -np)
	np="$1"
        nodigits=`echo $np | sed 's/^[0-9]*$//'`
        if [ "$nodigits" != "" -o $np -lt 1 ] ; then
           echo np: $np is an invalid number of processors.  Exiting.
           exit 1
	fi
	shift
	;;
    -machine)
	shift
	;;
    -machinefile)
        machineFileArg="-machinefile"
        machineFile="$1"
	shift
	;;
    -device)
	shift
	;;
    -stdin)
	shift
	;;
    -stdout)
        shift
        ;;
    -stderr)
        shift
        ;;
    -nolocal)
	;;	
    -h)
	if [ "$hasprinthelp" = 1 ] ; then
	   PrintHelp
        fi
      	exit 1
	;;	
    -e)
	;;
    -pg)
      	;;
    -leave_pg|-keep_pg)
	;;
    -batch)
        ;;
    -jid)
        shift
        ;;
    -globusrsl)
	shift
	;;
    -globusdb)
	shift
	;;
    -globusargs)
	shift
	;;
    -p4pg)
	shift
	;;
    -p4wd)
	shift
	;;
    -tcppg)
	shift
	;;
    -p4ssport)
	shift
	;;
    -paragontype)
	shift
	;;
    -paragonname)
	shift
	;;
    -paragonpn)
	shift
	;;
    -v)
       	mpirun_verbose=1
	;;
    -t)
      	just_testing=1
	Show=echo
	;;
    -tv|-totalview)
	;;
    -ksq)
        ;;
    -dbx)
      	;;
    -gdb)
	;;
    -xxgdb)
	;;
    -ddd)
	;;
    -pedb)
	;;
    -nopoll)
	;;
    -maxtime|-cpu)
	shift
	;;
    -mem)
	shift
	;;
    -mvhome)
	;;
    -mvback)
	shift
	;;
    -cac)
	shift
	;;
    -echo)
	;;
    -usage|-help|-\?)
      	# Accept these for help until the program name is provided.
      	if [ "$progname" = "" ] ; then
	   if [ "$hasprinthelp" = "1" ] ; then
	      PrintHelp
           fi
	   exit 1
      	fi
	;;
    *)
	# The first unrecognized argument is assumed to be the name of
      	# the program, but only if it is executable
	proginstance=`echo $arg | sed "s/%a/$arch/g"`
      	if [ "$progname" = "" -a "$fake_progname" = "" -a \
		! -x "$proginstance" ] ; then
	    fake_progname="$arg"
      	elif [ "$progname" = "" -a -x "$proginstance" ] ; then 
	    progname="$arg"
            # any following unrecognized arguments are assumed to be arguments
            # to be passed to the program, as well as all future args
	    while [ 1 -le $# ] ; do
               cmdLineArgs="$cmdLineArgs $1"
	       shift
            done
         else
	    echo "Warning: Command line arguments for program should be given"
            echo "after the program name.  Assuming that $arg is a"
            echo "command line argument for the program."
            cmdLineArgsExecer="$cmdLineArgsExecer -arg=$arg"
            cmdLineArgs="$cmdLineArgs $arg"
         fi
      ;;
  esac
done

# We need at least the program name

if [ "$progname" = "" ] ; then
  echo "Missing: program name"
  if [ "$fake_progname" != "" ] ; then
      echo "Program $fake_progname either does not exist, is not "
      echo "executable, or is an erroneous argument to mpirun."
  fi
  exit 1
fi
#
# Fill out relative program pathnames
#
# Get the current directory
# Note that PWD may NOT be `pwd` if an explicit "cd", outside of the csh
# shell, is used.  A downside of this is that PWD may have a more reasonable
# version of the path.  To try and fix this, we create a test file and see
# if it is accessible from PWD and pwd; if so, we take the PWD value
# 
# Why can't automounters work!???!!
#
# For those unfamiliar with the problem, the automounter creates
# paths like /tmp_mnt/.... .  But if you try to open a file with that path, 
# and the ACTUAL path has not been accessed before, the automounter fails
# to mount the partition.  In otherwords, the automounter is so mind-bogglingly
# stupid as to not recognize its OWN MOUNTS.  Network computing indeed.
#
# Note that PWD may ALSO be damaged, so we need to sed PWD as well...
#
# We should move this to the point in the code where it needs to know a
# particular filename, since this will fail if the directory is not
# writable by the user.
# 
if [ -n "sed -e s@/tmp_mnt/@/@g" ] ; then
    PWDtest=`pwd | sed -e s@/tmp_mnt/@/@g`
    if [ ! -d $PWDtest ] ; then
        PWDtest=`pwd`
    fi
    if [ -n "$PWD" ] ; then
	# Use a process-specific filename
	PWDtest2=`echo $PWD | sed -e s@/tmp_mnt/@/@g`
        /bin/rm -f $PWDtest/.mpirtmp$$ $PWDtest2/.mpirtmp$$
        if `eval "echo test > $PWDtest2/.mpirtmp$$" 2>/dev/null` ; then
            if [ ! -s $PWDtest/.mpirtmp$$ ] ; then
	        /bin/rm -f $PWDtest2/.mpirtmp$$
                PWD=$PWDtest
	    else
		PWD=$PWDtest2
	    fi
	else
	    # Current directory is not writable.  Hope for the best
            PWD=$PWDtest        
        fi
        /bin/rm -f $PWDtest/.mpirtmp$$ $PWDtest2/.mpirtmp$$
    else 
        PWD=$PWDtest
    fi
else
    PWD=`pwd`
fi
#
if [ -n "$PWD" ] ; then
    PWD_TRIAL=$PWD
else
    PWD_TRIAL=$PWDtest
fi
# The test for PWD_TRIAL usable is within the p4/execer/tcp test (since that
# is where it matters)
#
tail=`echo $progname | sed 's/\/.*//'` 
if  [ "$tail" = "" ] ; then
  #echo Absolute path, don't need to change anything
  true
else
  #echo Relative path
  progname="$PWD_TRIAL/$progname"
fi

if [ $mpirun_verbose = 1 ] ; then
  echo "running $progname on $np $arch $machine processors"
fi

$Show $progname $cmdLineArgs $machineFileArg $machineFile -GAMMANP $np
